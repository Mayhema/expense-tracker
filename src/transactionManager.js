import { AppState } from "./appState.js";
import { updateCharts } from "./charts/chartManager.js";
import { HEADERS } from "./constants.js";
import { isExcelDate, excelDateToJSDate } from "./fileHandler.js";
import { showToast } from "./uiManager.js";
import { getContrastColor } from "./utils.js";

const TRANSACTION_STORAGE_KEY = "transactions";

export function saveTransactionData(transactions) {
  localStorage.setItem(TRANSACTION_STORAGE_KEY, JSON.stringify(transactions));
}

export function getTransactionData() {
  return JSON.parse(localStorage.getItem(TRANSACTION_STORAGE_KEY) || "[]");
}

export function categorizeTransaction(description, category) {
  const transactions = getTransactionData();
  transactions.forEach(transaction => {
    if (transaction.description === description) {
      transaction.category = category;
    }
  });
  saveTransactionData(transactions);
}

// Modify the renderTransactions function
export function renderTransactions(transactions, skipChartUpdate = false) {
  const table = document.getElementById("transactionsTable");
  if (!table) return;

  // For large datasets, limit the number of rendered rows
  const MAX_DISPLAY_ROWS = 500;
  let displayedTransactions = transactions;
  let showingLimitMessage = false;
  
  if (transactions.length > MAX_DISPLAY_ROWS) {
    displayedTransactions = transactions.slice(0, MAX_DISPLAY_ROWS);
    showingLimitMessage = true;
  }
  
  // Reorganize columns to put Category on the right
  let html = `
    <thead>
      <tr>
        <th>Date</th>
        <th>Description</th>
        <th>Income</th>
        <th>Expenses</th>
        <th>Category</th>
      </tr>
    </thead>
    <tbody>
  `;
  
  if (transactions.length === 0) {
    html += '<tr><td colspan="5" style="text-align: center;">No transactions to display</td></tr>';
  } else {
    // Use string concatenation instead of mapping for better performance
    for (let idx = 0; idx < displayedTransactions.length; idx++) {
      const tx = displayedTransactions[idx];
      const isAutoGenerated = tx.autoGenerated;
      const descriptionClass = isAutoGenerated ? 'class="auto-generated" title="Auto-generated"' : '';
      
      // Create category dropdown with colors
      const categoryDropdown = createCategoryDropdown(idx, tx.category);
      
      html += `
        <tr>
          <td>${tx.date || ""}</td>
          <td ${descriptionClass}>${tx.description || ""}</td>
          <td>${tx.income || ""}</td>
          <td>${tx.expenses || ""}</td>
          <td>${categoryDropdown}</td>
        </tr>
      `;
    }
    
    if (showingLimitMessage) {
      html += `
        <tr>
          <td colspan="5" style="text-align: center; background-color: #fff3cd; padding: 8px;">
            Showing ${MAX_DISPLAY_ROWS} of ${transactions.length} transactions. 
            Use filters to narrow results.
          </td>
        </tr>
      `;
    }
  }
  
  html += '</tbody>';
  table.innerHTML = html;

  // Update summary
  const summary = document.getElementById("summary");
  if (summary) {
    renderSummary(transactions); // Show summary based on ALL transactions
  }

  // Update charts with a delay
  if (!skipChartUpdate) {
    setTimeout(() => {
      try {
        updateCharts(transactions); // Pass all transactions to charts
      } catch (error) {
        console.error("Error updating charts after rendering transactions:", error);
      }
    }, 100);
  }
}

/**
 * Creates a styled dropdown for categories with proper colors
 * @param {number} idx - Index of the transaction
 * @param {string} currentCategory - Currently selected category
 * @returns {string} HTML for the category dropdown
 */
function createCategoryDropdown(idx, currentCategory) {
  const categories = AppState.categories || {};
  
  return `
    <select 
      onchange="window.changeTxCategory(${idx}, this.value)" 
      class="category-dropdown"
      style="width: 100%;"
    >
      <option value="">Uncategorized</option>
      ${Object.entries(categories).map(([name, color]) => `
        <option 
          value="${name}" 
          ${currentCategory === name ? 'selected' : ''} 
          style="background-color: ${color}; color: ${getContrastColor(color)};" 
          data-color="${color}"
        >${name}</option>
      `).join('')}
    </select>
  `;
}

// Update the validateTransaction function
function validateTransaction(tx) {
  // Start tracking validation issues
  const issues = [];
  
  // Clean up empty values
  Object.keys(tx).forEach(key => {
    if (tx[key] === "") tx[key] = null;
  });
  
  // Check required fields
  if (!tx.date) issues.push("Missing date");
  
  if (!tx.income && !tx.expenses) issues.push("Missing income or expenses");
  
  // Handle missing description
  if (!tx.description) {
    // Auto-generate a description
    tx.description = tx.income 
      ? `Income on ${tx.date}` 
      : `Expense on ${tx.date}`;
    tx.autoGenerated = true;
  }
  
  // Convert non-string description to string
  if (tx.description && typeof tx.description !== "string") {
    tx.description = String(tx.description);
  }
  
  // Log validation issues for debugging
  if (issues.length > 0) {
    console.warn(`Transaction validation issues: ${issues.join(", ")}`, tx);
    return false;
  }
  
  return true;
}

// Improve Excel date handling

export function updateTransactions() {
  try {
    console.log("Starting transaction update process...");
    
    // Process files one by one for better debugging
    const transactions = [];
    
    AppState.mergedFiles.forEach(file => {
      console.log(`Processing file: ${file.fileName}`);
      console.log(`Header mapping:`, file.headerMapping);
      
      file.data.forEach((row, rowIndex) => {
        const transaction = {};
        
        // Map each column according to the header mapping
        file.headerMapping.forEach((header, colIndex) => {
          if (header === "â€“" || colIndex >= row.length) return;
          
          // Normalize header to lowercase for consistency
          const key = header.toLowerCase();
          transaction[key] = row[colIndex];
          
          // Special handling for dates
          if (key === "date" && !isNaN(parseFloat(row[colIndex]))) {
            const numValue = parseFloat(row[colIndex]);
            if (numValue > 35000 && numValue < 50000) {
              // Convert Excel date
              const jsDate = new Date((numValue - 25569) * 86400 * 1000);
              transaction[key] = jsDate.toISOString().split('T')[0];
              console.log(`Converted Excel date ${row[colIndex]} to ${transaction[key]}`);
            }
          }
        });
        
        // Add source file info
        transaction.fileName = file.fileName;
        transaction.rowIndex = rowIndex;
        
        // Log the transaction for debugging
        console.log(`Row ${rowIndex} mapped to:`, JSON.stringify(transaction));
        
        // Validate before adding
        if (validateTransaction(transaction)) {
          transactions.push(transaction);
        }
      });
    });
    
    console.log(`Processed ${transactions.length} valid transactions`);
    
    // Update the global transactions list
    AppState.transactions = transactions;
    
    // Render transactions without updating chart
    renderTransactions(transactions, true);
    
    // Update chart separately with a delay to avoid conflicts
    setTimeout(() => {
      try {
        updateCharts(transactions);
      } catch (chartError) {
        console.error("Chart error:", chartError);
      }
    }, 100);
    
  } catch (error) {
    console.error("Error in updateTransactions:", error);
    showToast("Error processing transactions. See console for details.", "error");
  }
}

window.changeTxCategory = function (idx, cat) {
  const tx = AppState.transactions[idx];
  tx.category = cat;
  AppState.transactions.forEach(t => {
    if (t.description === tx.description && !t.category) {
      t.category = cat;
    }
  });
  renderTransactions(AppState.transactions);
  updateCharts(AppState.transactions);
};

export function openEditTransactionsModal() {
  const modal = document.createElement("div");
  modal.id = "transactionModal";
  modal.style.position = "fixed";
  modal.style.top = "50%";
  modal.style.left = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "8px";
  modal.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.2)";
  modal.style.zIndex = "1000";

  modal.innerHTML = `
    <div>
      <h2>Edit Transactions</h2>
      <table id="editTransactionTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Description</th>
            <th>Category</th>
            <th>Income</th>
            <th>Expenses</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${AppState.transactions
            .map(
              (tx, idx) => `
            <tr>
              <td>${tx.date || ""}</td>
              <td>${tx.description || ""}</td>
              <td>
                <select onchange="changeTxCategory(${idx}, this.value)">
                  ${Object.keys(AppState.categories)
                    .map(cat => `<option value="${cat}" ${tx.category === cat ? "selected" : ""}>${cat}</option>`)
                    .join("")}
                </select>
              </td>
              <td>${tx.income || ""}</td>
              <td>${tx.expenses || ""}</td>
              <td><button onclick="deleteTransaction(${idx})">Delete</button></td>
            </tr>
          `
            )
            .join("")}
        </tbody>
      </table>
      <button id="closeTransactionModalBtn">Close</button>
    </div>
  `;
  document.body.appendChild(modal);

  document.getElementById("closeTransactionModalBtn").onclick = () => {
    modal.remove();
  };
}

export function applyFilters(filters) {
  const filteredTransactions = AppState.transactions.filter(tx => {
    const matchesDate =
      (!filters.startDate || new Date(tx.date) >= new Date(filters.startDate)) &&
      (!filters.endDate || new Date(tx.date) <= new Date(filters.endDate));
    const matchesCategory =
      !filters.category || tx.category === filters.category;
    const matchesAmount =
      (!filters.minAmount || 
        (tx.income && parseFloat(tx.income) >= filters.minAmount) || 
        (tx.expenses && parseFloat(tx.expenses) >= filters.minAmount)) &&
      (!filters.maxAmount || 
        (tx.income && parseFloat(tx.income) <= filters.maxAmount) || 
        (tx.expenses && parseFloat(tx.expenses) <= filters.maxAmount));

    return matchesDate && matchesCategory && matchesAmount;
  });

  renderTransactions(filteredTransactions);
}

export function renderSummary(transactions) {
  const totalIncome = transactions
    .filter(tx => tx.income)
    .reduce((sum, tx) => sum + parseFloat(tx.income || 0), 0);
  
  const totalExpenses = transactions
    .filter(tx => tx.expenses)
    .reduce((sum, tx) => sum + parseFloat(tx.expenses || 0), 0);

  const summary = document.getElementById("summary");
  if (!summary) return;

  summary.innerHTML = `
    <div class="section">
      <h2>Summary</h2>
      <p>Total Income: ${totalIncome.toFixed(2)}</p>
      <p>Total Expenses: ${totalExpenses.toFixed(2)}</p>
      <p>Savings: ${(totalIncome - totalExpenses).toFixed(2)}</p>
    </div>
  `;
}

export function addTransactionSearch() {
  const searchInput = document.getElementById("transactionSearch");
  if (!searchInput) return;

  searchInput.addEventListener("input", (event) => {
    const query = event.target.value.toLowerCase();
    const filteredTransactions = AppState.transactions.filter((tx) =>
      tx.description?.toLowerCase().includes(query)
    );
    renderTransactions(filteredTransactions);
  });
}