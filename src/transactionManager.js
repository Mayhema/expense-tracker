import { AppState } from "./appState.js";
import { updateChart } from "./chartManager.js";
import { HEADERS } from "./constants.js";
import { isExcelDate, excelDateToJSDate } from "./fileHandler.js";
import { showToast } from "./uiManager.js";

const TRANSACTION_STORAGE_KEY = "transactions";

export function saveTransactionData(transactions) {
  localStorage.setItem(TRANSACTION_STORAGE_KEY, JSON.stringify(transactions));
}

export function getTransactionData() {
  return JSON.parse(localStorage.getItem(TRANSACTION_STORAGE_KEY) || "[]");
}

export function categorizeTransaction(description, category) {
  const transactions = getTransactionData();
  transactions.forEach(transaction => {
    if (transaction.description === description) {
      transaction.category = category;
    }
  });
  saveTransactionData(transactions);
}

// Update the renderTransactions function

export function renderTransactions(transactions, skipChartUpdate = false) {
  const table = document.getElementById("transactionsTable");
  if (!table) return;

  table.innerHTML = `
    <thead>
      <tr>
        <th>Date</th>
        <th>Description</th>
        <th>Category</th>
        <th>Income</th>
        <th>Expenses</th>
      </tr>
    </thead>
    <tbody>
      ${transactions.length === 0 ? 
        '<tr><td colspan="5" style="text-align: center;">No transactions to display</td></tr>' :
        transactions.map(
          tx => {
            // Check if description was auto-generated
            const isAutoGenerated = tx.autoGenerated;
            const descriptionClass = isAutoGenerated ? 'class="auto-generated" title="Auto-generated"' : '';
            
            return `
            <tr>
              <td>${tx.date || ""}</td>
              <td ${descriptionClass}>${tx.description || ""}</td>
              <td>${tx.category || "Uncategorized"}</td>
              <td>${tx.income || ""}</td>
              <td>${tx.expenses || ""}</td>
            </tr>
          `;
          }
        ).join("")}
    </tbody>
  `;

  const summary = document.getElementById("summary");
  if (summary) {
    renderSummary(transactions);
  }

  if (!skipChartUpdate) {
    updateChart(transactions);
  }
}

// Update the validateTransaction function
function validateTransaction(tx) {
  // Convert empty strings to proper empty values
  Object.keys(tx).forEach(key => {
    if (tx[key] === "") tx[key] = null;
  });

  // Ensure we have either income or expenses field
  if (!tx.income && !tx.expenses) {
    console.warn(`Missing income/expenses for transaction:`, tx);
    return false;
  }
  
  if (!tx.date) {
    console.warn(`Missing date for transaction:`, tx);
    return false;
  }
  
  // Description validation - handle empty or invalid descriptions
  if (!tx.description) {
    console.log(`Empty description for transaction - generating default:`, tx);
    // Generate a default description for transactions without one
    tx.description = tx.income 
      ? `Income ${tx.date}` 
      : `Expense ${tx.date}`;
    tx.autoGenerated = true; // Flag auto-generated descriptions
    return true;
  }
  
  // Make sure description is a string
  if (typeof tx.description !== "string") {
    console.log(`Converting non-string description to string:`, tx);
    tx.description = String(tx.description);
  }
  
  return true;
}

// Improve Excel date handling

export function updateTransactions() {
  try {
    console.log("Starting transaction update...");
    const transactions = AppState.mergedFiles.flatMap(file => {
      // Log the file we're processing for debugging
      console.log(`Processing file: ${file.fileName}, Mapping:`, file.headerMapping);
      
      return file.data.map(row => {
        const transaction = {};
        file.headerMapping.forEach((header, i) => {
          if (header !== "â€“" && i < row.length) {
            // Normalize header keys to lowercase for consistency
            const key = header.toLowerCase();
            transaction[key] = row[i];
            
            // Log what we're mapping for debugging
            console.log(`Mapping ${header}: ${row[i]}`);
          }
        });

        // More robust Excel date conversion
        if (transaction.date) {
          // If it's a number that looks like an Excel date
          if (typeof transaction.date === 'number' || 
              (!isNaN(parseFloat(transaction.date)) && 
               parseFloat(transaction.date) > 30000 && 
               parseFloat(transaction.date) < 50000)) {
            
            console.log("Converting Excel date:", transaction.date);
            transaction.date = excelDateToJSDate(parseFloat(transaction.date));
          } 
          // If it's not already a string, convert it
          else if (typeof transaction.date !== "string") {
            transaction.date = String(transaction.date);
          }
        }

        transaction.fileName = file.fileName;
        return transaction;
      });
    }).filter(validateTransaction);

    console.log("Processed transactions:", transactions);
    AppState.transactions = transactions;
    
    // Only call renderTransactions once
    renderTransactions(transactions, true);
    
    // Only call updateChart once and after rendering transactions
    setTimeout(() => updateChart(transactions), 10);
  } catch (error) {
    console.error("Error updating transactions:", error);
    showToast("Failed to update transactions.", "error");
  }
}

window.changeTxCategory = function (idx, cat) {
  const tx = AppState.transactions[idx];
  tx.category = cat;
  AppState.transactions.forEach(t => {
    if (t.description === tx.description && !t.category) {
      t.category = cat;
    }
  });
  renderTransactions(AppState.transactions);
  updateChart(AppState.transactions);
};

export function openEditTransactionsModal() {
  const modal = document.createElement("div");
  modal.id = "transactionModal";
  modal.style.position = "fixed";
  modal.style.top = "50%";
  modal.style.left = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "8px";
  modal.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.2)";
  modal.style.zIndex = "1000";

  modal.innerHTML = `
    <div>
      <h2>Edit Transactions</h2>
      <table id="editTransactionTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Description</th>
            <th>Category</th>
            <th>Income</th>
            <th>Expenses</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${AppState.transactions
            .map(
              (tx, idx) => `
            <tr>
              <td>${tx.date || ""}</td>
              <td>${tx.description || ""}</td>
              <td>
                <select onchange="changeTxCategory(${idx}, this.value)">
                  ${Object.keys(AppState.categories)
                    .map(cat => `<option value="${cat}" ${tx.category === cat ? "selected" : ""}>${cat}</option>`)
                    .join("")}
                </select>
              </td>
              <td>${tx.income || ""}</td>
              <td>${tx.expenses || ""}</td>
              <td><button onclick="deleteTransaction(${idx})">Delete</button></td>
            </tr>
          `
            )
            .join("")}
        </tbody>
      </table>
      <button id="closeTransactionModalBtn">Close</button>
    </div>
  `;
  document.body.appendChild(modal);

  document.getElementById("closeTransactionModalBtn").onclick = () => {
    modal.remove();
  };
}

export function applyFilters(filters) {
  const filteredTransactions = AppState.transactions.filter(tx => {
    const matchesDate =
      (!filters.startDate || new Date(tx.date) >= new Date(filters.startDate)) &&
      (!filters.endDate || new Date(tx.date) <= new Date(filters.endDate));
    const matchesCategory =
      !filters.category || tx.category === filters.category;
    const matchesAmount =
      (!filters.minAmount || 
        (tx.income && parseFloat(tx.income) >= filters.minAmount) || 
        (tx.expenses && parseFloat(tx.expenses) >= filters.minAmount)) &&
      (!filters.maxAmount || 
        (tx.income && parseFloat(tx.income) <= filters.maxAmount) || 
        (tx.expenses && parseFloat(tx.expenses) <= filters.maxAmount));

    return matchesDate && matchesCategory && matchesAmount;
  });

  renderTransactions(filteredTransactions);
}

export function renderSummary(transactions) {
  const totalIncome = transactions
    .filter(tx => tx.income)
    .reduce((sum, tx) => sum + parseFloat(tx.income || 0), 0);
  
  const totalExpenses = transactions
    .filter(tx => tx.expenses)
    .reduce((sum, tx) => sum + parseFloat(tx.expenses || 0), 0);

  const summary = document.getElementById("summary");
  if (!summary) return;

  summary.innerHTML = `
    <div class="section">
      <h2>Summary</h2>
      <p>Total Income: ${totalIncome.toFixed(2)}</p>
      <p>Total Expenses: ${totalExpenses.toFixed(2)}</p>
      <p>Savings: ${(totalIncome - totalExpenses).toFixed(2)}</p>
    </div>
  `;
}

export function addTransactionSearch() {
  const searchInput = document.getElementById("transactionSearch");
  if (!searchInput) return;

  searchInput.addEventListener("input", (event) => {
    const query = event.target.value.toLowerCase();
    const filteredTransactions = AppState.transactions.filter((tx) =>
      tx.description?.toLowerCase().includes(query)
    );
    renderTransactions(filteredTransactions);
  });
}