import { AppState } from "../core/appState.js";
import { DEFAULT_CATEGORIES } from "../core/constants.js";
// Remove unused imports
// import { HEADERS } from "../core/constants.js";
import { showToast } from "./uiManager.js";
import { getContrastColor } from "../utils/utils.js";
import { addToCategoryMapping, getCategoryForDescription } from "./categoryMapping.js";
// Remove unused import: import { removeFromCategoryMapping } from "./categoryMapping.js";
// Remove unused import: import { formatDateForDisplay } from "../utils/dateUtils.js";
import { parseDateString } from "../utils/dateUtils.js";
import { formatCurrency, CURRENCIES, DEFAULT_CURRENCY } from "../constants/currencies.js";

const TRANSACTION_STORAGE_KEY = "transactions";

export function saveTransactionData(transactions) {
  localStorage.setItem(TRANSACTION_STORAGE_KEY, JSON.stringify(transactions));
}

export function getTransactionData() {
  return JSON.parse(localStorage.getItem(TRANSACTION_STORAGE_KEY) || "[]");
}

export function categorizeTransaction(description, category) {
  const transactions = getTransactionData();
  transactions.forEach(transaction => {
    if (transaction.description === description) {
      transaction.category = category;
    }
  });
  saveTransactionData(transactions);
}

// Create an editable row for a transaction with improved UI
function createEditableRow(tx, index) {
  // Break into smaller functions
  const dateFormatted = formatTransactionDate(tx);
  const descriptionClasses = getDescriptionClasses(tx);
  const editedClass = tx.edited ? 'edited' : '';

  // Handle category and subcategory display
  const categoryDisplay = createCategoryDisplay(tx);

  // Create row HTML with the prepared parts
  return createRowHtml(tx, index, dateFormatted, descriptionClasses, editedClass, categoryDisplay);
}

// Helper functions
function formatTransactionDate(tx) {
  // Date formatting logic
  let displayDate = tx.date || "";
  if (displayDate && /^\d{4}-\d{2}-\d{2}$/.test(displayDate)) {
    try {
      const date = new Date(displayDate);
      if (!isNaN(date.getTime())) {
        const day = date.getDate().toString().padStart(2, '0');
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const year = date.getFullYear();
        displayDate = `${day}/${month}/${year}`;
      }
    } catch (e) {
      console.error('Error formatting date for display:', e);
    }
  }
  return displayDate;
}

function getDescriptionClasses(tx) {
  const descriptionClass = tx.autoGenerated ? 'class="auto-generated" title="Auto-generated"' : '';
  const dateEdited = tx.originalData && tx.date !== tx.originalData.date ? 'edited-cell' : '';
  const descEdited = tx.originalData && tx.description !== tx.originalData.description ? 'edited-cell' : '';
  const incomeEdited = tx.originalData && tx.income !== tx.originalData.income ? 'edited-cell' : '';
  const expensesEdited = tx.originalData && tx.expenses !== tx.originalData.expenses ? 'edited-cell' : '';
  const categoryEdited = tx.originalData && tx.category !== tx.originalData.category ? 'edited-cell' : '';
  return { descriptionClass, dateEdited, descEdited, incomeEdited, expensesEdited, categoryEdited };
}

// Fix useless variable assignments
function createCategoryDisplay(tx) {
  let subcategoryDisplay = '';
  let backgroundColor = '';
  let textColor = '';

  if (tx.category && AppState.categories[tx.category]) {
    const categoryValue = AppState.categories[tx.category];

    if (typeof categoryValue === 'string') {
      backgroundColor = categoryValue;
      textColor = getContrastColor(backgroundColor);
    } else if (categoryValue.color) {
      backgroundColor = categoryValue.color;
      textColor = getContrastColor(backgroundColor);
    }

    if (tx.subcategory && categoryValue.subcategories &&
      categoryValue.subcategories[tx.subcategory]) {
      subcategoryDisplay = tx.subcategory;
      // Use subcategory color if available
      backgroundColor = categoryValue.subcategories[tx.subcategory];
      textColor = getContrastColor(backgroundColor);
    }
  }

  return {
    categoryDisplay: tx.category || '',
    subcategoryDisplay,
    backgroundColor,
    textColor
  };
}

function createRowHtml(tx, index, date, descClasses, editedClass, categoryDisplay) {
  // HTML assembly logic
  const formattedIncome = tx.income ? formatCurrency(tx.income, tx.currency || DEFAULT_CURRENCY) : "";
  const formattedExpenses = tx.expenses ? formatCurrency(tx.expenses, tx.currency || DEFAULT_CURRENCY) : "";

  return `
    <tr id="tx-row-${index}" class="transaction-row ${editedClass}" data-index="${index}">
      <td class="${descClasses.dateEdited}">${date}</td>
      <td ${descClasses.descriptionClass} class="${descClasses.descEdited}">${tx.description || ""}</td>
      <td class="${descClasses.incomeEdited}">${formattedIncome}</td>
      <td class="${descClasses.expensesEdited}">${formattedExpenses}</td>
      <td class="category-cell ${descClasses.categoryEdited}">
        <div class="category-wrapper">
          ${createCategoryDropdown(index, categoryDisplay.categoryDisplay, categoryDisplay.subcategoryDisplay)}
          ${categoryDisplay.subcategoryDisplay}
        </div>
      </td>
      <td class="actions-cell">
        <button class="edit-button" onclick="window.editTransaction(${index})" title="Edit transaction">‚úèÔ∏è</button>
        <button class="currency-button" onclick="window.editTransactionCurrency(${index})" title="Change currency">üí±</button>
        ${tx.edited ? `<button class="revert-button" onclick="window.revertTransaction(${index})" title="Revert to original">‚Ü©Ô∏è</button>` : ''}
      </td>
    </tr>
  `;
}

// Creates a styled dropdown for categories with improved UI and subcategory support
function createCategoryDropdown(rowIndex, selectedCategory, selectedSubcategory) {
  const categories = AppState.categories || {};
  // Always include empty option first
  let options = '<option value="">None</option>';

  // Sort categories alphabetically
  const sortedCategories = Object.entries(categories).sort((a, b) => {
    const nameA = typeof a[1] === 'object' && a[1].parent ? a[1].parent + ":" + a[0] : a[0];
    const nameB = typeof b[1] === 'object' && b[1].parent ? b[1].parent + ":" + b[0] : b[0];
    return nameA.localeCompare(nameB);
  });

  // First add main categories
  sortedCategories.forEach(([name, value]) => {
    // Skip subcategories (they'll be handled differently)
    if (typeof value === 'object' && value.parent) return;

    // Get the color - either directly or from the object
    const color = typeof value === 'string' ? value : (value.color || '#cccccc');
    const textColor = getContrastColor(color);

    options += `<option
      value="${name}"
      ${selectedCategory === name ? 'selected' : ''}
      style="background-color: ${color}; color: ${textColor}; padding: 4px;"
      data-color="${color}"
      data-text-color="${textColor}"
      data-has-subcategories="${typeof value === 'object' && value.subcategories && Object.keys(value.subcategories).length > 0}"
    >${name}</option>`;
  });

  // Use dynamic styling for selected value
  let selectedColorStyle = '';

  if (selectedCategory) {
    const catValue = categories[selectedCategory];
    if (catValue) {
      let color;
      if (typeof catValue === 'string') {
        color = catValue;
      } else if (catValue.color) {
        color = catValue.color;
      }

      if (color) {
        selectedColorStyle = `style="background-color: ${color}; color: ${getContrastColor(color)}"`;
      }
    }
  }

  // Create a data attribute that indicates if a subcategory is available/selected
  const hasSubcategories = selectedCategory &&
    categories[selectedCategory] &&
    typeof categories[selectedCategory] === 'object' &&
    categories[selectedCategory].subcategories &&
    Object.keys(categories[selectedCategory].subcategories).length > 0;

  // Return enhanced dropdown with onchange handler that now includes subcategory support
  return `<select
    onchange="window.changeTxCategory(${rowIndex}, this.value)"
    class="category-select"
    data-index="${rowIndex}"
    data-subcategory="${selectedSubcategory || ''}"
    data-has-subcategories="${hasSubcategories}"
    ${selectedColorStyle}
  >${options}</select>
  ${hasSubcategories ? createSubcategoryDropdown(rowIndex, selectedCategory, selectedSubcategory) : ''}`;
}

// Helper function to get subcategory dropdown
function createSubcategoryDropdown(rowIndex, mainCategory, selectedSubcategory) {
  if (!mainCategory || !AppState.categories[mainCategory] ||
    typeof AppState.categories[mainCategory] !== 'object' ||
    !AppState.categories[mainCategory].subcategories ||
    Object.keys(AppState.categories[mainCategory].subcategories).length === 0) {
    return '';
  }

  const subcategories = AppState.categories[mainCategory].subcategories;
  let options = '<option value="">None</option>';

  // Sort subcategories alphabetically
  const sortedSubcategories = Object.entries(subcategories).sort((a, b) => a[0].localeCompare(b[0]));

  sortedSubcategories.forEach(([name, color]) => {
    const textColor = getContrastColor(color);
    options += `<option
      value="${name}"
      ${selectedSubcategory === name ? 'selected' : ''}
      style="background-color: ${color}; color: ${textColor}; padding: 4px;"
      data-color="${color}"
      data-text-color="${textColor}"
    >${name}</option>`;
  });

  // Use dynamic styling for selected value
  let selectedColorStyle = '';
  if (selectedSubcategory && subcategories[selectedSubcategory]) {
    const color = subcategories[selectedSubcategory];
    selectedColorStyle = `style="background-color: ${color}; color: ${getContrastColor(color)}"`;
  }

  return `<select
    onchange="window.changeTxSubcategory(${rowIndex}, this.value)"
    class="subcategory-select"
    data-index="${rowIndex}"
    ${selectedColorStyle}
  >${options}</select>`;
}

// Validate a transaction before adding or updating
function validateTransaction(tx) {
  // Start tracking validation issues
  const issues = [];

  // Clean up empty values
  Object.keys(tx).forEach(key => {
    if (tx[key] === "") tx[key] = null;
  });

  // Check required fields
  if (!tx.date) issues.push("Missing date");
  if (!tx.income && !tx.expenses) issues.push("Missing income or expenses");

  // Handle missing description
  if (!tx.description) {
    // Auto-generate a description
    tx.description = tx.income
      ? `Income on ${tx.date}`
      : `Expense on ${tx.date}`;
    tx.autoGenerated = true;
  }

  // Convert non-string description to string
  if (tx.description && typeof tx.description !== "string") {
    tx.description = String(tx.description);
  }

  // Log validation issues for debugging
  if (issues.length > 0) {
    console.warn(`Transaction validation issues: ${issues.join(", ")}`, tx);
    return false;
  }

  return true;
}

// Fix high cognitive complexity by breaking down functions
export function renderTransactions(transactions) {
  const table = document.getElementById("transactionsTable");
  if (!table) return;

  prepareTableStructure(table);
  renderTransactionBatches(transactions, table);
  updateSummary(transactions);
}

function prepareTableStructure(table) {
  table.innerHTML = `
    <thead>
      <tr>
        <th>Date</th>
        <th>Description</th>
        <th>Income</th>
        <th>Expenses</th>
        <th>Category</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="transactionsBody"></tbody>
  `;
}

function renderTransactionBatches(transactions, table) {
  const MAX_DISPLAY = 500;
  const BATCH_SIZE = 100;
  const tbody = document.getElementById("transactionsBody");

  if (!transactions || transactions.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No transactions to display</td></tr>';
    return;
  }

  renderBatchesRecursively(transactions, tbody, 0, Math.min(transactions.length, MAX_DISPLAY), BATCH_SIZE);
}

function renderBatchesRecursively(transactions, tbody, renderedCount, displayCount, batchSize) {
  const batch = transactions.slice(renderedCount, renderedCount + batchSize);
  if (batch.length === 0) {
    if (transactions.length > displayCount) {
      const limitRow = document.createElement("tr");
      limitRow.innerHTML = `
        <td colspan="6" style="text-align: center; background-color: #fff3cd; padding: 8px;">
          Showing ${displayCount} of ${transactions.length} transactions.
          Use filters to narrow results.
        </td>
      `;
      tbody.appendChild(limitRow);
    }
    return;
  }

  batch.forEach(tx => {
    if (renderedCount >= displayCount) return;

    const row = document.createElement("tr");
    row.innerHTML = createEditableRow(tx, renderedCount);
    row.setAttribute('data-index', renderedCount.toString());

    tbody.appendChild(row);
    renderedCount++;
  });

  if (renderedCount < displayCount) {
    setTimeout(() => renderBatchesRecursively(transactions, tbody, renderedCount, displayCount, batchSize), 0);
  }
}

function updateSummary(transactions) {
  const summary = document.getElementById("summary");
  if (summary) {
    renderSummary(transactions);
  }
}

// Function to update transactions from merged files
export function updateTransactions() {
  try {
    console.log("Starting transaction update process...");

    // Store existing transactions by description for preserving categories
    const existingTxByDesc = {};

    // First load existing categories from any source
    const storedTransactions = localStorage.getItem("transactions");
    if (storedTransactions) {
      try {
        const savedTransactions = JSON.parse(storedTransactions);
        if (Array.isArray(savedTransactions)) {
          savedTransactions.forEach(tx => {
            if (tx.description && tx.category) {
              existingTxByDesc[tx.description] = tx.category;
            }
          });
        }
      } catch (e) {
        console.error("Error parsing stored transactions:", e);
      }
    }

    // Also check current transactions
    if (AppState.transactions) {
      AppState.transactions.forEach(tx => {
        if (tx.description && tx.category) {
          existingTxByDesc[tx.description] = tx.category;
        }
      });
    }

    // Process files one by one for better debugging
    const transactions = [];

    AppState.mergedFiles.forEach(file => {
      console.log(`Processing file: ${file.fileName}`);
      console.log(`Header mapping:`, file.headerMapping);

      file.data.forEach((row, rowIndex) => {
        const transaction = {};

        // Map each column according to the header mapping
        file.headerMapping.forEach((header, colIndex) => {
          if (header === "‚Äì" || colIndex >= row.length) return;

          // Normalize header to lowercase for consistency
          const key = header.toLowerCase();
          transaction[key] = row[colIndex];

          // Special handling for dates
          if (key === "date" && !isNaN(parseFloat(row[colIndex]))) {
            const numValue = parseFloat(row[colIndex]);
            if (numValue > 35000 && numValue < 50000) {
              // Convert Excel date
              const jsDate = new Date((numValue - 25569) * 86400 * 1000);
              transaction[key] = jsDate.toISOString().split('T')[0];
              console.log(`Converted Excel date ${row[colIndex]} to ${transaction[key]}`);
            }
          }
        });

        // Add source file info and currency
        transaction.fileName = file.fileName;
        transaction.rowIndex = rowIndex;
        transaction.currency = file.currency || DEFAULT_CURRENCY;

        // Preserve category if we've seen this description before
        if (transaction.description && existingTxByDesc[transaction.description]) {
          transaction.category = existingTxByDesc[transaction.description];
        }
        // Otherwise try auto-categorization for new transactions
        else if (transaction.description && typeof getCategoryForDescription === 'function') {
          const categoryFromMapping = getCategoryForDescription(transaction.description);
          if (categoryFromMapping) {
            transaction.category = categoryFromMapping;
            transaction.autoCategorized = true;
          }
        }

        // Get category from row if it was pre-categorized during import
        if (row.category && !transaction.category) {
          transaction.category = row.category;
        }

        // Validate before adding
        if (validateTransaction(transaction)) {
          transactions.push(transaction);
        }
      });
    });

    console.log(`Processed ${transactions.length} valid transactions`);

    // Update the global transactions list
    AppState.transactions = transactions;

    // Render transactions
    renderTransactions(transactions);

    // Import and update charts AFTER transactions are processed
    import("../charts/chartManager.js").then(module => {
      if (typeof module.updateChartsWithCurrentData === 'function') {
        module.updateChartsWithCurrentData();
      }
    }).catch(error => {
      console.error("Error updating charts:", error);
    });

  } catch (error) {
    console.error("Error in updateTransactions:", error);
    showToast("Error processing transactions. See console for details.", "error");
  }
}

// Change category of a transaction - update to apply colors and handle subcategories
window.changeTxCategory = function (transactionIndex, newCategory) {
  // Find the transaction
  const tx = AppState.transactions[transactionIndex];
  if (!tx) return;

  // Record original category for history if this is an edit
  if (!tx.originalData && tx.category !== newCategory) {
    tx.originalData = {
      date: tx.date,
      description: tx.description,
      income: tx.income,
      expenses: tx.expenses,
      category: tx.category,
      subcategory: tx.subcategory
    };
    tx.edited = true;
  }

  // Update the category
  tx.category = newCategory;

  // Clear subcategory if category changed
  if (tx.subcategory) {
    delete tx.subcategory;
  }

  // If this is the first time category is being changed, mark as categorized
  if (!tx.categorized && newCategory) {
    tx.categorized = true;
  }

  // Get the row containing this transaction
  const row = document.querySelector(`tr[data-index="${transactionIndex}"]`);
  if (!row) return;

  // Get the category cell
  const categoryCell = row.querySelector('.category-cell');
  if (!categoryCell) return;

  // Update the cell with proper category (and potentially subcategory) dropdown
  const categoryValue = AppState.categories[newCategory];
  const hasSubcategories = categoryValue &&
    typeof categoryValue === 'object' &&
    categoryValue.subcategories &&
    Object.keys(categoryValue.subcategories).length > 0;

  // Update the category wrapper
  const categoryWrapper = categoryCell.querySelector('.category-wrapper');
  if (categoryWrapper) {
    // Update the category dropdown style
    const categorySelect = categoryWrapper.querySelector('.category-select');
    if (categorySelect && newCategory) {
      let color;
      if (typeof categoryValue === 'string') {
        color = categoryValue;
      } else if (categoryValue && categoryValue.color) {
        color = categoryValue.color;
      }

      if (color) {
        const textColor = getContrastColor(color);
        categorySelect.style.backgroundColor = color;
        categorySelect.style.color = textColor;
      }
    } else if (categorySelect) {
      // Reset styling if no category
      categorySelect.style.backgroundColor = '';
      categorySelect.style.color = '';
    }

    // Handle subcategory dropdown (add or remove)
    const existingSubSelect = categoryWrapper.querySelector('.subcategory-select');

    if (hasSubcategories) {
      if (existingSubSelect) {
        // Update options in existing dropdown
        existingSubSelect.innerHTML = createSubcategoryOptions(newCategory);
      } else {
        // Create new subcategory dropdown
        const subDropdown = document.createElement('div');
        subDropdown.className = 'subcategory-dropdown';
        subDropdown.style.marginTop = '5px';
        subDropdown.innerHTML = createSubcategoryDropdown(transactionIndex, newCategory);
        categoryWrapper.appendChild(subDropdown);
      }
    } else if (existingSubSelect) {
      // Remove subcategory dropdown if category has no subcategories
      existingSubSelect.remove();
    }
  }

  // Add to category mapping system if not already there and if we have a category
  if (newCategory && tx.description) {
    addToCategoryMapping(tx.description, newCategory);
  }

  // If removing category mapping, remove from category mapping system
  if (!newCategory && tx.description) {
    // Import the function if not available
    import("./categoryMapping.js").then(module => {
      if (module.removeFromCategoryMapping) {
        module.removeFromCategoryMapping(tx.description);
      }
    }).catch(err => {
      console.error("Error importing removeFromCategoryMapping:", err);
    });
  }

  // Save to localStorage
  localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

  // Update charts with new categorization
  setTimeout(() => {
    import("../charts/chartManager.js").then(module => {
      if (typeof module.updateChartsWithCurrentData === 'function') {
        module.updateChartsWithCurrentData();
      }
    }).catch(err => console.error("Error updating charts:", err));
  }, 0);
};

// New function to change subcategory
window.changeTxSubcategory = function (transactionIndex, newSubcategory) {
  const tx = AppState.transactions[transactionIndex];
  if (!tx || !tx.category) return;

  // Record original data if this is the first edit
  if (!tx.originalData) {
    tx.originalData = {
      date: tx.date,
      description: tx.description,
      income: tx.income,
      expenses: tx.expenses,
      category: tx.category,
      subcategory: tx.subcategory
    };
    tx.edited = true;
  }

  // Update subcategory
  if (newSubcategory) {
    tx.subcategory = newSubcategory;
  } else {
    delete tx.subcategory;
  }

  // Save to localStorage
  localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

  // Update the select element styling
  const select = document.querySelector(`tr[data-index="${transactionIndex}"] .subcategory-select`);
  if (select && newSubcategory) {
    const categoryValue = AppState.categories[tx.category];
    if (categoryValue && categoryValue.subcategories && categoryValue.subcategories[newSubcategory]) {
      const color = categoryValue.subcategories[newSubcategory];
      const textColor = getContrastColor(color);
      select.style.backgroundColor = color;
      select.style.color = textColor;
    }
  } else if (select) {
    select.style.backgroundColor = '';
    select.style.color = '';
  }
};

// Helper function to create edit form in a row with improved UI
function createEditForm(row, tx, index) {
  // Format the date in ISO format for the date input
  const isoDate = tx.date ? formatDateToISO(tx.date) : '';

  // Add subcategory dropdown if needed
  let subcategoryDropdown = '';
  if (tx.category) {
    const categoryValue = AppState.categories[tx.category];
    if (typeof categoryValue === 'object' && categoryValue.subcategories &&
      Object.keys(categoryValue.subcategories).length > 0) {
      subcategoryDropdown = `
        <div style="margin-top: 5px;">
          <select id="edit-subcategory-${index}" class="edit-input">
            <option value="">No subcategory</option>
            ${Object.entries(categoryValue.subcategories).map(([name, color]) => `
              <option value="${name}" ${tx.subcategory === name ? 'selected' : ''}
                      style="background-color: ${color}; color: ${getContrastColor(color)};">
                ${name}
              </option>
            `).join('')}
          </select>
        </div>`;
    }
  }

  row.innerHTML = `
    <td>
      <input type="date" id="edit-date-${index}" value="${isoDate}" class="edit-input" />
    </td>
    <td>
      <input type="text" id="edit-desc-${index}" value="${tx.description || ''}" class="edit-input" />
    </td>
    <td>
      <input type="number" id="edit-income-${index}" value="${tx.income || ''}" step="0.01" class="edit-input" />
    </td>
    <td>
      <input type="number" id="edit-expenses-${index}" value="${tx.expenses || ''}" step="0.01" class="edit-input" />
    </td>
    <td>
      ${createCategoryDropdown(index, tx.category, tx.subcategory)}
      ${subcategoryDropdown}
    </td>
    <td class="edit-actions">
      <button onclick="window.saveTransaction(${index})" class="save-button" title="Save changes">üíæ</button>
      <button onclick="window.cancelEdit(${index})" class="cancel-button" title="Cancel editing">‚ùå</button>
    </td>
  `;
}

// Helper function to convert any date format to ISO format (YYYY-MM-DD)
function formatDateToISO(dateStr) {
  if (!dateStr) return '';

  try {
    // If the date is already in ISO format
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
      return dateStr;
    }

    // If it's in DD/MM/YYYY format
    const dateParts = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (dateParts) {
      const [, day, month, year] = dateParts;
      return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
    }

    // Try using the Date object as a fallback
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      return date.toISOString().split('T')[0];
    }

    return dateStr; // Return as is if we can't parse it
  } catch (e) {
    console.error('Error formatting date to ISO:', e);
    return dateStr;
  }
}

// Edit a transaction
function editTransaction(index) {
  console.log(`Edit transaction called for index: ${index}`);
  const tx = AppState.transactions[index];
  if (!tx) {
    console.error("Transaction not found at index:", index);
    return;
  }

  // Store original data if not already stored
  if (!AppState.originalTransactions) {
    AppState.originalTransactions = [];
  }

  if (!AppState.originalTransactions[index]) {
    AppState.originalTransactions[index] = { ...tx };
    console.log("Stored original transaction:", AppState.originalTransactions[index]);
  }

  // Create an edit form
  const row = document.querySelector(`tr[data-index="${index}"]`);
  if (!row) {
    console.error("Transaction row not found with index:", index);
    // Fallback to finding by position
    const rows = document.querySelectorAll('#transactionsTable tbody tr');
    if (rows[index]) {
      console.log("Found row by position instead");
      createEditForm(rows[index], tx, index);
    } else {
      showToast("Could not find transaction row to edit", "error");
    }
    return;
  }

  createEditForm(row, tx, index);
}

// Save an edited transaction
function saveTransaction(index) {
  const tx = AppState.transactions[index];
  if (!tx) return;

  // Store original data if not already stored
  if (!tx.originalData) {
    tx.originalData = {
      date: tx.date,
      description: tx.description,
      income: tx.income,
      expenses: tx.expenses,
      category: tx.category,
      subcategory: tx.subcategory
    };
  }

  // Get edited values
  const dateInput = document.getElementById(`edit-date-${index}`);
  const descInput = document.getElementById(`edit-desc-${index}`);
  const incomeInput = document.getElementById(`edit-income-${index}`);
  const expensesInput = document.getElementById(`edit-expenses-${index}`);
  const categorySelect = document.querySelector(`tr[data-index="${index}"] .category-select`);
  const subcategorySelect = document.getElementById(`edit-subcategory-${index}`);

  if (!dateInput || !descInput || !incomeInput || !expensesInput || !categorySelect) {
    console.error("Could not find all edit inputs");
    showToast("Error saving transaction", "error");
    return;
  }

  // Update transaction
  tx.date = dateInput.value;
  tx.description = descInput.value;
  tx.income = incomeInput.value ? parseFloat(incomeInput.value) : '';
  tx.expenses = expensesInput.value ? parseFloat(expensesInput.value) : '';
  tx.category = categorySelect.value;

  // Update subcategory if present
  if (subcategorySelect) {
    if (subcategorySelect.value) {
      tx.subcategory = subcategorySelect.value;
    } else {
      delete tx.subcategory;
    }
  }

  tx.edited = true;

  // Save to localStorage
  localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

  // If adding to a category, also add to category mapping
  if (tx.category && tx.description) {
    addToCategoryMapping(tx.description, tx.category);
  }

  // Re-render the transactions to show the updated data
  renderTransactions(AppState.transactions);
  showToast("Transaction updated", "success");
}

// Cancel editing a transaction
function cancelEdit(index) {
  // Just re-render the transactions to discard changes
  renderTransactions(AppState.transactions);
}

// Revert a transaction to its original state
function revertTransaction(index) {
  const tx = AppState.transactions[index];
  if (!tx || !tx.originalData) {
    showToast("No original data found to revert to", "error");
    return;
  }

  if (!confirm("Revert this transaction to its original state?")) return;

  // Restore original data
  tx.date = tx.originalData.date;
  tx.description = tx.originalData.description;
  tx.income = tx.originalData.income;
  tx.expenses = tx.originalData.expenses;
  tx.category = tx.originalData.category;

  // Clean up
  delete tx.edited;
  delete tx.originalData;

  // Save to localStorage
  localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

  // Re-render the transactions
  renderTransactions(AppState.transactions);
  showToast("Transaction reverted to original", "success");
}

// Filter transactions by criteria
export function applyFilters(filters) {
  // Convert dates from DD/MM/YYYY display format to YYYY-MM-DD for comparison
  let startDate = filters.startDate ? parseDateString(filters.startDate) : null;
  let endDate = filters.endDate ? parseDateString(filters.endDate) : null;

  // Get the current category filters (from toggleable category buttons)
  const categoryFilters = AppState.currentCategoryFilters || [];

  const filteredTransactions = AppState.transactions.filter(tx => {
    const txDate = tx.date ? new Date(tx.date) : null;

    // Date filter
    const matchesDate =
      (!startDate || (txDate && txDate >= startDate)) &&
      (!endDate || (txDate && txDate <= endDate));

    // Dropdown category filter
    const matchesDropdownCategory =
      !filters.category || tx.category === filters.category;

    // Button category filters (toggled categories)
    const matchesButtonCategories =
      categoryFilters.length === 0 ||
      (tx.category && categoryFilters.includes(tx.category));

    // Amount filter
    const matchesAmount =
      (!filters.minAmount ||
        (tx.income && parseFloat(tx.income) >= filters.minAmount) ||
        (tx.expenses && parseFloat(tx.expenses) >= filters.minAmount)) &&
      (!filters.maxAmount ||
        (tx.income && parseFloat(tx.income) <= filters.maxAmount) ||
        (tx.expenses && parseFloat(tx.expenses) <= filters.maxAmount));

    return matchesDate && matchesDropdownCategory && matchesButtonCategories && matchesAmount;
  });

  renderTransactions(filteredTransactions);
}

// Render transactions summary as a horizontal row instead of stacked
export function renderSummary(transactions) {
  if (!transactions || !Array.isArray(transactions)) return;

  const summary = document.getElementById("summary");
  if (!summary) return;

  const totalIncome = transactions
    .filter(tx => tx.income)
    .reduce((sum, tx) => sum + parseFloat(tx.income || 0), 0);

  const totalExpenses = transactions
    .filter(tx => tx.expenses)
    .reduce((sum, tx) => sum + parseFloat(tx.expenses || 0), 0);

  const balance = totalIncome - totalExpenses;
  const balanceClass = balance >= 0 ? "positive-balance" : "negative-balance";

  summary.innerHTML = `
    <div class="summary-row">
      <div class="summary-item">
        <span class="summary-label">Income:</span>
        <span class="summary-value income-value">$${totalIncome.toFixed(2)}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Expenses:</span>
        <span class="summary-value expense-value">$${totalExpenses.toFixed(2)}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Balance:</span>
        <span class="summary-value ${balanceClass}">$${balance.toFixed(2)}</span>
      </div>
    </div>
  `;

  // Add styles for the summary
  const style = document.createElement("style");
  style.textContent = `
    .summary-row {
      display: flex;
      justify-content: space-around;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .dark-mode .summary-row {
      background-color: #333;
    }
    .summary-item {
      text-align: center;
      padding: 0 15px;
    }
    .summary-label {
      font-weight: bold;
      margin-right: 8px;
    }
    .summary-value {
      font-size: 1.2em;
    }
    .income-value {
      color: #4CAF50;
    }
    .expense-value {
      color: #F44336;
    }
    .positive-balance {
      color: #4CAF50;
    }
    .negative-balance {
      color: #F44336;
    }
  `;

  document.head.appendChild(style);
}

// Add search function for transactions
export function addTransactionSearch() {
  const searchInput = document.getElementById("transactionSearch");
  if (!searchInput) return;

  searchInput.addEventListener("input", (event) => {
    const query = event.target.value.toLowerCase();
    const filteredTransactions = AppState.transactions.filter((tx) =>
      tx.description?.toLowerCase().includes(query)
    );
    renderTransactions(filteredTransactions);
  });
}

// Open a modal to edit all transactions
export function openEditTransactionsModal() {
  const modal = document.createElement("div");
  modal.id = "transactionModal";
  modal.style.position = "fixed";
  modal.style.top = "50%";
  modal.style.left = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "8px";
  modal.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.2)";
  modal.style.zIndex = "1000";

  let tableRows = '';
  AppState.transactions.forEach((tx, idx) => {
    tableRows += `
      <tr>
        <td>${tx.date || ""}</td>
        <td>${tx.description || ""}</td>
        <td>
          <select onchange="window.changeTxCategory(${idx}, this.value)">
            <option value="">Select...</option>
            ${Object.keys(AppState.categories)
        .map(cat => `<option value="${cat}" ${tx.category === cat ? "selected" : ""}>${cat}</option>`)
        .join("")}
          </select>
        </td>
        <td>${tx.income || ""}</td>
        <td>${tx.expenses || ""}</td>
        <td><button onclick="window.deleteTransaction(${idx})">Delete</button></td>
      </tr>
    `;
  });

  modal.innerHTML = `
    <div>
      <h2>Edit Transactions</h2>
      <table id="editTransactionTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Description</th>
            <th>Category</th>
            <th>Income</th>
            <th>Expenses</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
      <button id="closeTransactionModalBtn">Close</button>
    </div>
  `;

  document.body.appendChild(modal);

  document.getElementById("closeTransactionModalBtn").onclick = () => {
    modal.remove();
  };
}

// Delete a transaction
function deleteTransaction(index) {
  if (confirm(`Delete this transaction?`)) {
    AppState.transactions.splice(index, 1);
    localStorage.setItem("transactions", JSON.stringify(AppState.transactions));
    renderTransactions(AppState.transactions);
    showToast("Transaction deleted", "success");
  }
}

// Add a new function to edit transaction currency
function editTransactionCurrency(index) {
  const tx = AppState.transactions[index];
  if (!tx) return;

  // Create currency selection modal
  const modalContent = document.createElement('div');
  modalContent.innerHTML = `
    <div class="currency-edit-container">
      <p>Select currency for "${tx.description || 'this transaction'}":</p>
      <select id="txCurrencySelect" class="form-control">
        ${Object.entries(CURRENCIES).map(([code, curr]) =>
    `<option value="${code}" ${code === (tx.currency || DEFAULT_CURRENCY) ? 'selected' : ''}>
             ${curr.name} (${curr.symbol})
           </option>`
  ).join('')}
      </select>
      <div class="buttons-container" style="margin-top: 20px; text-align: right;">
        <button id="cancelCurrencyBtn" class="btn btn-secondary">Cancel</button>
        <button id="saveCurrencyBtn" class="btn btn-primary">Save</button>
      </div>
    </div>
  `;

  import("./modalManager.js").then(module => {
    const modal = module.showModal({
      title: "Edit Transaction Currency",
      content: modalContent,
      size: 'small'
    });

    // Add event listeners
    document.getElementById('cancelCurrencyBtn').addEventListener('click', () => {
      modal.close();
    });

    document.getElementById('saveCurrencyBtn').addEventListener('click', () => {
      // Store original if not already stored
      if (!tx.originalData) {
        tx.originalData = {
          date: tx.date,
          description: tx.description,
          income: tx.income,
          expenses: tx.expenses,
          category: tx.category,
          subcategory: tx.subcategory,
          currency: tx.currency
        };
        tx.edited = true;
      }

      // Update currency
      tx.currency = document.getElementById('txCurrencySelect').value;

      // Save to localStorage
      localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

      // Close modal and update UI
      modal.close();
      renderTransactions(AppState.transactions);
      showToast("Currency updated", "success");
    });
  }).catch(err => {
    console.error("Error loading modal manager:", err);
    showToast("Could not open currency editor", "error");
  });
}

// Store a reference to the original function
const originalRenderTransactions = renderTransactions;

// Now safely redefine the function
renderTransactions = function(transactions, skipChartUpdate = false) {
  // Note: we're calling the stored original function, not the redefined one
  originalRenderTransactions(transactions);

  // Now also update the category filter dropdown and buttons
  updateCategoryFilterDropdown();
  renderCategoryButtons();

  // Make sure the filtering based on category buttons works
  const activeCategories = AppState.currentCategoryFilters || [];
  document.querySelectorAll(".category-btn").forEach(btn => {
    const category = btn.getAttribute("data-category");
    if (category === 'all') {
      btn.classList.toggle('active', activeCategories.length === 0);
      btn.classList.toggle('inactive', activeCategories.length > 0);
    } else {
      btn.classList.toggle('active', activeCategories.includes(category));
      btn.classList.toggle('inactive', !activeCategories.includes(category));
    }
  });
};

// Attach necessary functions to window object for HTML event bindings
document.addEventListener('DOMContentLoaded', function () {
  window.editTransaction = editTransaction;
  window.saveTransaction = saveTransaction;
  window.cancelEdit = cancelEdit;
  window.revertTransaction = revertTransaction;
  window.changeTxCategory = changeTxCategory;
  window.deleteTransaction = deleteTransaction;
  window.editTransactionCurrency = editTransactionCurrency;
  console.log("Transaction functions attached to window");

  // Initialize transaction search if available
  addTransactionSearch();

  // Format date inputs to DD/MM/YYYY
  initializeDateFilters();
});

// Initialize date filter inputs with proper format
function initializeDateFilters() {
  const filterStartDate = document.getElementById('filterStartDate');
  const filterEndDate = document.getElementById('filterEndDate');

  if (filterStartDate) {
    // Add event listener to format displayed date
    filterStartDate.addEventListener('change', function () {
      if (this.value) {
        // Store the ISO format as data attribute for filtering
        this.dataset.isoDate = this.value;

        // Convert to DD/MM/YYYY format for display
        try {
          const date = new Date(this.value);
          if (!isNaN(date.getTime())) {
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();

            this.type = 'text';
            this.value = `${day}/${month}/${year}`;
          }
        } catch (e) {
          console.error('Error formatting date:', e);
        }
      }
    });

    // Handle focus to switch back to date input
    filterStartDate.addEventListener('focus', function () {
      this.type = 'date';
      if (this.dataset.isoDate) {
        this.value = this.dataset.isoDate;
      }
    });
  }

  if (filterEndDate) {
    // Same handling for end date
    filterEndDate.addEventListener('change', function () {
      if (this.value) {
        this.dataset.isoDate = this.value;

        try {
          const date = new Date(this.value);
          if (!isNaN(date.getTime())) {
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();

            this.type = 'text';
            this.value = `${day}/${month}/${year}`;
          }
        } catch (e) {
          console.error('Error formatting date:', e);
        }
      }
    });

    filterEndDate.addEventListener('focus', function () {
      this.type = 'date';
      if (this.dataset.isoDate) {
        this.value = this.dataset.isoDate;
      } else {
        // Clear the field when focusing if no ISO date is stored
        this.value = '';
      }
    });
  }
}

/**
 * Renders category buttons for filtering and adds click handlers
 */
export function renderCategoryButtons() {
  const categoryList = document.getElementById("categoryList");
  if (!categoryList) return;

  // Check if we have categories defined
  if (!AppState.categories || Object.keys(AppState.categories).length === 0) {
    console.warn("No categories found, using default set from constants.js");
    AppState.categories = DEFAULT_CATEGORIES;
    localStorage.setItem("expenseCategories", JSON.stringify(AppState.categories));
  }

  // Initialize currentCategoryFilters if needed
  AppState.currentCategoryFilters = AppState.currentCategoryFilters || [];

  // Get current active categories
  const activeCategories = AppState.currentCategoryFilters || [];

  // Create a button for "All"
  let html = `
    <button class="category-btn ${activeCategories.length === 0 ? 'active' : 'inactive'}"
      data-category="all" style="background-color: #999; color: white;">
      All
    </button>
  `;

  // Create buttons for each category
  Object.entries(AppState.categories).forEach(([category, value]) => {
    const color = typeof value === 'object' ? value.color : value;
    const textColor = getContrastColor(color);
    const isActive = activeCategories.includes(category);

    html += `
      <button class="category-btn ${isActive ? 'active' : 'inactive'}"
        data-category="${category}"
        style="background-color: ${color}; color: ${textColor}">
        ${category}
      </button>
    `;
  });

  categoryList.innerHTML = html;

  // Add click event to each button
  document.querySelectorAll(".category-btn").forEach(btn => {
    btn.addEventListener("click", function () {
      const category = this.getAttribute("data-category");

      if (category === 'all') {
        // Reset to show all
        AppState.currentCategoryFilters = [];
        document.querySelectorAll(".category-btn").forEach(b => {
          b.classList.toggle('active', b.getAttribute("data-category") === 'all');
          b.classList.toggle('inactive', b.getAttribute("data-category") !== 'all');
        });
      } else {
        // Toggle the clicked category's state
        const allBtn = document.querySelector('.category-btn[data-category="all"]');
        allBtn.classList.remove('active');
        allBtn.classList.add('inactive');

        this.classList.toggle('active');
        this.classList.toggle('inactive');

        if (this.classList.contains('active')) {
          // Add to filter
          if (!AppState.currentCategoryFilters.includes(category)) {
            AppState.currentCategoryFilters.push(category);
          }
        } else {
          // Remove from filter
          AppState.currentCategoryFilters = AppState.currentCategoryFilters.filter(c => c !== category);
        }
      }

      // Apply the filters to transactions
      const filters = {
        category: ''
      };

      // Get other filter values
      const filterStartDate = document.getElementById('filterStartDate');
      if (filterStartDate) {
        filters.startDate = filterStartDate.value;
      }

      const filterEndDate = document.getElementById('filterEndDate');
      if (filterEndDate) {
        filters.endDate = filterEndDate.value;
      }

      const filterMinAmount = document.getElementById('filterMinAmount');
      if (filterMinAmount) {
        filters.minAmount = filterMinAmount.value;
      }

      const filterMaxAmount = document.getElementById('filterMaxAmount');
      if (filterMaxAmount) {
        filters.maxAmount = filterMaxAmount.value;
      }

      applyFilters(filters);
    });
  });
}

/**
 * Updates the category filter dropdown with available categories
 */
function updateCategoryFilterDropdown() {
  const filterCategory = document.getElementById('filterCategory');
  if (!filterCategory) return;

  // Clear existing options except the first one
  while (filterCategory.options.length > 1) {
    filterCategory.remove(1);
  }

  // Add options for each category
  const categories = AppState.categories || {};
  Object.keys(categories).sort().forEach(category => {
    const option = document.createElement('option');
    option.value = category;
    option.textContent = category;

    // If it's a complex category with color information
    const categoryValue = categories[category];
    if (typeof categoryValue === 'object' && categoryValue.color) {
      option.style.backgroundColor = categoryValue.color;
      option.style.color = getContrastColor(categoryValue.color);
    }
    // If it's a simple category
    else if (typeof categoryValue === 'string') {
      option.style.backgroundColor = categoryValue;
      option.style.color = getContrastColor(categoryValue);
    }

    filterCategory.appendChild(option);
  });
}

// Override renderTransactions with our enhanced version
renderTransactions = function(transactions, skipChartUpdate = false) {
  // Call the original function
  originalRenderTransactions(transactions);

  // Now also update the category filter dropdown and buttons
  updateCategoryFilterDropdown();
  renderCategoryButtons();

  // Make sure the filtering based on category buttons works
  const activeCategories = AppState.currentCategoryFilters || [];
  document.querySelectorAll(".category-btn").forEach(btn => {
    const category = btn.getAttribute("data-category");
    if (category === 'all') {
      btn.classList.toggle('active', activeCategories.length === 0);
      btn.classList.toggle('inactive', activeCategories.length > 0);
    } else {
      btn.classList.toggle('active', activeCategories.includes(category));
      btn.classList.toggle('inactive', !activeCategories.includes(category));
    }
  });
};
