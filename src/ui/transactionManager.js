import { AppState } from "../core/appState.js";
import { showToast } from "./uiManager.js";
import { getContrastColor } from "../utils/utils.js";
import { addToCategoryMapping } from "./categoryMapping.js";
import { parseDateString } from "../utils/dateUtils.js";
import { formatCurrency, CURRENCIES, DEFAULT_CURRENCY } from "../constants/currencies.js";

const TRANSACTION_STORAGE_KEY = "transactions";

export function saveTransactionData(transactions) {
  localStorage.setItem(TRANSACTION_STORAGE_KEY, JSON.stringify(transactions));
}

export function getTransactionData() {
  return JSON.parse(localStorage.getItem(TRANSACTION_STORAGE_KEY) || "[]");
}

export function categorizeTransaction(description, category) {
  const transactions = getTransactionData();
  transactions.forEach(transaction => {
    if (transaction.description === description) {
      transaction.category = category;
    }
  });
  saveTransactionData(transactions);
}

// Create an editable row for a transaction with improved UI
function createEditableRow(tx, index) {
  // Break into smaller functions
  const dateFormatted = formatTransactionDate(tx);
  const descriptionClasses = getDescriptionClasses(tx);
  const editedClass = tx.edited ? 'edited' : '';

  // Handle category and subcategory display
  const categoryDisplay = createCategoryDisplay(tx);

  // Create row HTML with the prepared parts
  return createRowHtml(tx, index, dateFormatted, descriptionClasses, editedClass, categoryDisplay);
}

// Helper functions
function formatTransactionDate(tx) {
  // Date formatting logic
  let displayDate = tx.date || "";
  if (displayDate && /^\d{4}-\d{2}-\d{2}$/.test(displayDate)) {
    try {
      const date = new Date(displayDate);
      if (!isNaN(date.getTime())) {
        const day = date.getDate().toString().padStart(2, '0');
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const year = date.getFullYear();
        displayDate = `${day}/${month}/${year}`;
      }
    } catch (e) {
      console.error('Error formatting date for display:', e);
    }
  }
  return displayDate;
}

function getDescriptionClasses(tx) {
  const descriptionClass = tx.autoGenerated ? 'class="auto-generated" title="Auto-generated"' : '';
  const dateEdited = tx.originalData && tx.date !== tx.originalData.date ? 'edited-cell' : '';
  const descEdited = tx.originalData && tx.description !== tx.originalData.description ? 'edited-cell' : '';
  const incomeEdited = tx.originalData && tx.income !== tx.originalData.income ? 'edited-cell' : '';
  const expensesEdited = tx.originalData && tx.expenses !== tx.originalData.expenses ? 'edited-cell' : '';
  const categoryEdited = tx.originalData && tx.category !== tx.originalData.category ? 'edited-cell' : '';
  return { descriptionClass, dateEdited, descEdited, incomeEdited, expensesEdited, categoryEdited };
}

// Fix useless variable assignments
function createCategoryDisplay(tx) {
  let subcategoryDisplay = '';
  let backgroundColor = '';
  let textColor = '';

  if (tx.category && AppState.categories[tx.category]) {
    const categoryValue = AppState.categories[tx.category];

    if (typeof categoryValue === 'string') {
      backgroundColor = categoryValue;
      textColor = getContrastColor(backgroundColor);
    } else if (categoryValue.color) {
      backgroundColor = categoryValue.color;
      textColor = getContrastColor(backgroundColor);
    }

    if (tx.subcategory && categoryValue.subcategories &&
      categoryValue.subcategories[tx.subcategory]) {
      subcategoryDisplay = tx.subcategory;
      // Use subcategory color if available
      backgroundColor = categoryValue.subcategories[tx.subcategory];
      textColor = getContrastColor(backgroundColor);
    }
  }

  return {
    categoryDisplay: tx.category || '',
    subcategoryDisplay,
    backgroundColor,
    textColor
  };
}

function createRowHtml(tx, index, date, descClasses, editedClass, categoryDisplay) {
  // HTML assembly logic
  const formattedIncome = tx.income ? formatCurrency(tx.income, tx.currency || DEFAULT_CURRENCY) : "";
  const formattedExpenses = tx.expenses ? formatCurrency(tx.expenses, tx.currency || DEFAULT_CURRENCY) : "";

  return `
    <tr id="tx-row-${index}" class="transaction-row ${editedClass}" data-index="${index}">
      <td class="${descClasses.dateEdited}">${date}</td>
      <td ${descClasses.descriptionClass} class="${descClasses.descEdited}">${tx.description || ""}</td>
      <td class="${descClasses.incomeEdited}">${formattedIncome}</td>
      <td class="${descClasses.expensesEdited}">${formattedExpenses}</td>
      <td class="category-cell ${descClasses.categoryEdited}">
        ${createCategoryDropdown(index, categoryDisplay.categoryDisplay, categoryDisplay.subcategoryDisplay)}
      </td>
      <td class="actions-cell">
        <button class="edit-button" onclick="window.editTransaction(${index})" title="Edit transaction">‚úèÔ∏è</button>
        <button class="currency-button" onclick="window.editTransactionCurrency(${index})" title="Change currency">üí±</button>
        ${tx.edited ? `<button class="revert-button" onclick="window.revertTransaction(${index})" title="Revert to original">‚Ü©Ô∏è</button>` : ''}
      </td>
    </tr>
  `;
}

// Creates a styled dropdown for categories with improved UI and subcategory support
function createCategoryDropdown(rowIndex, selectedCategory, selectedSubcategory) {
  const categories = AppState.categories || {};
  let options = '<option value="">None</option>';

  // Sort categories alphabetically
  const sortedCategories = Object.entries(categories).sort((a, b) => {
    const nameA = typeof a[1] === 'object' && a[1].parent ? a[1].parent + ":" + a[0] : a[0];
    const nameB = typeof b[1] === 'object' && b[1].parent ? b[1].parent + ":" + b[0] : b[0];
    return nameA.localeCompare(nameB);
  });

  // First add main categories
  sortedCategories.forEach(([name, value]) => {
    // Skip subcategories (they'll be handled differently)
    if (typeof value === 'object' && value.parent) return;

    // Get the color - either directly or from the object
    const color = typeof value === 'string' ? value : (value.color || '#cccccc');
    const textColor = getContrastColor(color);

    options += `<option
      value="${name}"
      ${selectedCategory === name ? 'selected' : ''}
      style="background-color: ${color}; color: ${textColor}; padding: 4px;"
      data-color="${color}"
      data-text-color="${textColor}"
      data-has-subcategories="${typeof value === 'object' && value.subcategories && Object.keys(value.subcategories).length > 0}"
    >${name}</option>`;
  });

  // Use dynamic styling for selected value
  let selectedColorStyle = '';

  if (selectedCategory) {
    const catValue = categories[selectedCategory];
    if (catValue) {
      let color;
      if (typeof catValue === 'string') {
        color = catValue;
      } else if (catValue.color) {
        color = catValue.color;
      }

      if (color) {
        selectedColorStyle = `style="background-color: ${color}; color: ${getContrastColor(color)}"`;
      }
    }
  }

  // Create a data attribute that indicates if a subcategory is available/selected
  const hasSubcategories = selectedCategory &&
    categories[selectedCategory] &&
    typeof categories[selectedCategory] === 'object' &&
    categories[selectedCategory].subcategories &&
    Object.keys(categories[selectedCategory].subcategories).length > 0;

  // Return complete category UI with both dropdowns in a container
  return `<div class="category-container" style="width: 100%;">
    <select
      onchange="window.changeTxCategory(${rowIndex}, this.value)"
      class="category-select"
      data-index="${rowIndex}"
      data-subcategory="${selectedSubcategory || ''}"
      data-has-subcategories="${hasSubcategories}"
      ${selectedColorStyle}
      style="width: 100%; min-width: 100%; box-sizing: border-box;"
    >${options}</select>
    ${hasSubcategories ? createSubcategoryDropdown(rowIndex, selectedCategory, selectedSubcategory) : ''}
  </div>`;
}

// Fix subcategory dropdown styling
function createSubcategoryDropdown(rowIndex, mainCategory, selectedSubcategory) {
  if (!mainCategory || !AppState.categories[mainCategory] ||
    typeof AppState.categories[mainCategory] !== 'object' ||
    !AppState.categories[mainCategory].subcategories ||
    Object.keys(AppState.categories[mainCategory].subcategories).length === 0) {
    return '';
  }

  const subcategories = AppState.categories[mainCategory].subcategories;
  let options = '<option value="">None</option>';

  // Sort subcategories alphabetically
  const sortedSubcategories = Object.entries(subcategories).sort((a, b) => a[0].localeCompare(b[0]));

  sortedSubcategories.forEach(([name, color]) => {
    const textColor = getContrastColor(color);
    options += `<option
      value="${name}"
      ${selectedSubcategory === name ? 'selected' : ''}
      style="background-color: ${color}; color: ${textColor}; padding: 4px;"
      data-color="${color}"
      data-text-color="${textColor}"
    >${name}</option>`;
  });

  // Use dynamic styling for selected value
  let selectedColorStyle = '';
  if (selectedSubcategory && subcategories[selectedSubcategory]) {
    const color = subcategories[selectedSubcategory];
    selectedColorStyle = `style="background-color: ${color}; color: ${getContrastColor(color)}"`;
  }

  return `<select
    onchange="window.changeTxSubcategory(${rowIndex}, this.value)"
    class="subcategory-select"
    data-index="${rowIndex}"
    ${selectedColorStyle}
    style="width: 100%; min-width: 100%; margin-top: 3px; box-sizing: border-box;"
  >${options}</select>`;
}

/**
 * Render transactions summary with currency support
 */
export function renderSummary(transactions) {
  if (!transactions || !Array.isArray(transactions)) return;

  const summary = document.getElementById("summary");
  if (!summary) return;

  // Group transactions by currency
  const currencyGroups = {};

  transactions.forEach(tx => {
    const currency = tx.currency || "USD";
    if (!currencyGroups[currency]) {
      currencyGroups[currency] = { income: 0, expenses: 0 };
    }

    if (tx.income) {
      currencyGroups[currency].income += parseFloat(tx.income || 0);
    }
    if (tx.expenses) {
      currencyGroups[currency].expenses += parseFloat(tx.expenses || 0);
    }
  });

  // Create summary HTML
  let summaryHTML = '<div class="summary-container">';

  // Add each currency group
  Object.entries(currencyGroups).forEach(([currency, data]) => {
    const balance = data.income - data.expenses;
    const balanceClass = balance >= 0 ? "positive-balance" : "negative-balance";

    // Get currency symbol from CURRENCIES constant
    const symbol = CURRENCIES[currency] ? CURRENCIES[currency].symbol : '$';

    summaryHTML += `
      <div class="summary-row">
        <div class="summary-currency-header">${currency}</div>
        <div class="summary-item">
          <span class="summary-label">Income:</span>
          <span class="summary-value income-value">${symbol}${data.income.toFixed(2)}</span>
        </div>
        <div class="summary-item">
          <span class="summary-label">Expenses:</span>
          <span class="summary-value expense-value">${symbol}${data.expenses.toFixed(2)}</span>
        </div>
        <div class="summary-item">
          <span class="summary-label">Balance:</span>
          <span class="summary-value ${balanceClass}">${symbol}${balance.toFixed(2)}</span>
        </div>
      </div>
    `;
  });

  summaryHTML += '</div>';
  summary.innerHTML = summaryHTML;

  // Add styles for the improved summary
  const style = document.createElement("style");
  style.textContent = `
    .summary-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .summary-currency-header {
      font-weight: bold;
      margin-right: 15px;
      min-width: 50px;
    }
    .summary-row {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 8px;
    }
    .dark-mode .summary-row {
      background-color: #333;
    }
    .summary-item {
      margin-right: 20px;
    }
    .summary-label {
      font-weight: bold;
      margin-right: 8px;
    }
    .summary-value {
      font-size: 1.2em;
    }
    .income-value {
      color: #4CAF50;
    }
    .expense-value {
      color: #F44336;
    }
    .positive-balance {
      color: #4CAF50;
    }
    .negative-balance {
      color: #F44336;
    }
  `;

  document.head.appendChild(style);
}

// Add search function for transactions
export function addTransactionSearch() {
  const searchInput = document.getElementById("transactionSearch");
  if (!searchInput) return;

  searchInput.addEventListener("input", (event) => {
    const query = event.target.value.toLowerCase();
    const filteredTransactions = AppState.transactions.filter((tx) =>
      tx.description?.toLowerCase().includes(query)
    );
    renderTransactions(filteredTransactions);
  });
}

// Open a modal to edit all transactions
export function openEditTransactionsModal() {
  const modal = document.createElement("div");
  modal.id = "transactionModal";
  modal.style.position = "fixed";
  modal.style.top = "50%";
  modal.style.left = "50%";
  modal.style.transform = "translate(-50%, -50%)";
  modal.style.background = "#fff";
  modal.style.padding = "20px";
  modal.style.borderRadius = "8px";
  modal.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.2)";
  modal.style.zIndex = "1000";

  let tableRows = '';
  AppState.transactions.forEach((tx, idx) => {
    tableRows += `
      <tr>
        <td>${tx.date || ""}</td>
        <td>${tx.description || ""}</td>
        <td>
          <select onchange="window.changeTxCategory(${idx}, this.value)">
            <option value="">Select...</option>
            ${Object.keys(AppState.categories)
        .map(cat => `<option value="${cat}" ${tx.category === cat ? "selected" : ""}>${cat}</option>`)
        .join("")}
          </select>
        </td>
        <td>${tx.income || ""}</td>
        <td>${tx.expenses || ""}</td>
        <td><button onclick="window.deleteTransaction(${idx})">Delete</button></td>
      </tr>
    `;
  });

  modal.innerHTML = `
    <div>
      <h2>Edit Transactions</h2>
      <table id="editTransactionTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Description</th>
            <th>Category</th>
            <th>Income</th>
            <th>Expenses</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
      <button id="closeTransactionModalBtn">Close</button>
    </div>
  `;

  document.body.appendChild(modal);

  document.getElementById("closeTransactionModalBtn").onclick = () => {
    modal.remove();
  };
}

// Delete a transaction
function deleteTransaction(index) {
  if (confirm(`Delete this transaction?`)) {
    AppState.transactions.splice(index, 1);
    localStorage.setItem("transactions", JSON.stringify(AppState.transactions));
    renderTransactions(AppState.transactions);
    showToast("Transaction deleted", "success");
  }
}

// Add a new function to edit transaction currency
function editTransactionCurrency(index) {
  const tx = AppState.transactions[index];
  if (!tx) return;

  // Create currency selection modal
  const modalContent = document.createElement('div');
  modalContent.innerHTML = `
    <div class="currency-edit-container">
      <p>Select currency for "${tx.description || 'this transaction'}":</p>
      <select id="txCurrencySelect" class="form-control">
        ${Object.entries(CURRENCIES).map(([code, curr]) =>
    `<option value="${code}" ${code === (tx.currency || DEFAULT_CURRENCY) ? 'selected' : ''}>
             ${curr.name} (${curr.symbol})
           </option>`
  ).join('')}
      </select>
      <div class="buttons-container" style="margin-top: 20px; text-align: right;">
        <button id="cancelCurrencyBtn" class="btn btn-secondary">Cancel</button>
        <button id="saveCurrencyBtn" class="btn btn-primary">Save</button>
      </div>
    </div>
  `;

  import("./modalManager.js").then(module => {
    const modal = module.showModal({
      title: "Edit Transaction Currency",
      content: modalContent,
      size: 'small'
    });

    // Add event listeners
    document.getElementById('cancelCurrencyBtn').addEventListener('click', () => {
      modal.close();
    });

    document.getElementById('saveCurrencyBtn').addEventListener('click', () => {
      // Store original if not already stored
      if (!tx.originalData) {
        tx.originalData = {
          date: tx.date,
          description: tx.description,
          income: tx.income,
          expenses: tx.expenses,
          category: tx.category,
          subcategory: tx.subcategory,
          currency: tx.currency
        };
        tx.edited = true;
      }

      // Update currency
      tx.currency = document.getElementById('txCurrencySelect').value;

      // Save to localStorage
      localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

      // Close modal and update UI
      modal.close();
      renderTransactions(AppState.transactions);
      showToast("Currency updated", "success");
    });
  }).catch(err => {
    console.error("Error loading modal manager:", err);
    showToast("Could not open currency editor", "error");
  });
}

/**
 * Renders transactions in the transactions table
 * @param {Array} transactions - Transactions to display
 * @param {boolean} skipChartUpdate - If true, won't trigger chart updates
 */
export function renderTransactions(transactions, skipChartUpdate = false) {
  // Get the transactions table body
  const tbody = document.getElementById("transactionsBody");
  if (!tbody) return;

  // Clear existing rows
  tbody.innerHTML = "";

  // If no transactions, show a message
  if (!transactions || transactions.length === 0) {
    tbody.innerHTML = `<tr><td colspan="6" style="text-align: center;">No transactions to display</td></tr>`;
    return;
  }

  // Render each transaction
  transactions.forEach((tx, index) => {
    tbody.innerHTML += createEditableRow(tx, index);
  });

  // Update summary information
  renderSummary(transactions);

  // Update charts if needed
  if (!skipChartUpdate) {
    import("../charts/chartManager.js")
      .then(chartModule => {
        if (typeof chartModule.updateChartsWithCurrentData === "function") {
          chartModule.updateChartsWithCurrentData();
        }
      })
      .catch(err => console.error("Error updating charts:", err));
  }
}

// Store a reference to the original function
const originalRenderTransactions = renderTransactions;

// Now safely redefine the function
renderTransactions = function (transactions, skipChartUpdate = false) {
  // Call the original function
  originalRenderTransactions(transactions, skipChartUpdate);

  // Now also update the category filter dropdown and buttons
  updateCategoryFilterDropdown();
  renderCategoryButtons();

  // Make sure the filtering based on category buttons works
  const activeCategories = AppState.currentCategoryFilters || [];
  document.querySelectorAll(".category-btn").forEach(btn => {
    const category = btn.getAttribute("data-category");
    if (category === 'all') {
      btn.classList.toggle('active', activeCategories.length === 0);
      btn.classList.toggle('inactive', activeCategories.length > 0);
    } else {
      btn.classList.toggle('active', activeCategories.includes(category));
      btn.classList.toggle('inactive', !activeCategories.includes(category));
    }
  });
};

/**
 * Updates the category filter dropdown with available categories
 */
function updateCategoryFilterDropdown() {
  const filterCategory = document.getElementById("filterCategory");
  if (!filterCategory) return;

  // Save the current selection
  const currentValue = filterCategory.value;

  // Clear options
  filterCategory.innerHTML = '<option value="">All</option>';

  // Add options for each category
  const categories = Object.keys(AppState.categories || {});
  categories.sort().forEach(category => {
    filterCategory.innerHTML += `<option value="${category}">${category}</option>`;
  });

  // Restore the selection
  filterCategory.value = currentValue;
}

// Filter transactions by criteria
export function applyFilters(filters) {
  // Convert dates from DD/MM/YYYY display format to YYYY-MM-DD for comparison
  let startDate = filters.startDate ? parseDateString(filters.startDate) : null;
  let endDate = filters.endDate ? parseDateString(filters.endDate) : null;

  // Get the current category filters (from toggleable category buttons)
  const categoryFilters = AppState.currentCategoryFilters || [];

  const filteredTransactions = AppState.transactions.filter(tx => {
    const txDate = tx.date ? new Date(tx.date) : null;

    // Date filter
    const matchesDate =
      (!startDate || (txDate && txDate >= startDate)) &&
      (!endDate || (txDate && txDate <= endDate));

    // Dropdown category filter
    const matchesDropdownCategory =
      !filters.category || tx.category === filters.category;

    // Button category filters (toggled categories)
    const matchesButtonCategories =
      categoryFilters.length === 0 ||
      (tx.category && categoryFilters.includes(tx.category));

    // Amount filter
    const matchesAmount =
      (!filters.minAmount ||
        (tx.income && parseFloat(tx.income) >= filters.minAmount) ||
        (tx.expenses && parseFloat(tx.expenses) >= filters.minAmount)) &&
      (!filters.maxAmount ||
        (tx.income && parseFloat(tx.income) <= filters.maxAmount) ||
        (tx.expenses && parseFloat(tx.expenses) <= filters.maxAmount));

    return matchesDate && matchesDropdownCategory && matchesButtonCategories && matchesAmount;
  });

  renderTransactions(filteredTransactions);
}

/**
 * Updates transactions by fetching from storage and rendering
 * This function is used by other modules that need to refresh the transaction display
 */
export function updateTransactions() {
  try {
    // Get transactions from merged files
    const transactions = processTransactionsFromFiles();

    // Store in AppState for other components to access
    AppState.transactions = transactions;

    // Save to localStorage
    saveTransactionData(transactions);

    // Render the transactions
    renderTransactions(transactions);

    // Update the summary values
    renderSummary(transactions);

    return transactions;
  } catch (err) {
    console.error("Error updating transactions:", err);
    showToast("Error updating transaction data", "error");
    return [];
  }
}

/**
 * Extracts and processes transactions from merged files
 * @returns {Array} Processed transaction objects
 */
function processTransactionsFromFiles() {
  const transactions = [];

  // Skip if no merged files
  if (!AppState.mergedFiles || AppState.mergedFiles.length === 0) {
    return transactions;
  }

  // Process only selected files
  AppState.mergedFiles
    .filter(file => file.selected !== false) // Include if selected or if selected property is missing
    .forEach(file => {
      // Process each file's data into transactions
      processFileDataIntoTransactions(file, transactions);
    });

  return transactions;
}

/**
 * Processes a single file's data into transactions
 * @param {Object} file - The merged file object
 * @param {Array} transactions - Array to add transactions to
 */
function processFileDataIntoTransactions(file, transactions) {
  if (!file.data || !file.headerMapping) return;

  const headerMapping = file.headerMapping;
  const dateIndex = headerMapping.indexOf("Date");
  const descIndex = headerMapping.indexOf("Description");
  const incomeIndex = headerMapping.indexOf("Income");
  const expenseIndex = headerMapping.indexOf("Expenses");

  // Skip file if no date or no amounts
  if (dateIndex === -1 || (incomeIndex === -1 && expenseIndex === -1)) return;

  file.data.forEach(row => {
    if (!row || row.length === 0) return;

    const transaction = {
      fileName: file.fileName,
      date: dateIndex >= 0 && dateIndex < row.length ? row[dateIndex] : null,
      description: descIndex >= 0 && descIndex < row.length ? row[descIndex] : null,
      income: incomeIndex >= 0 && incomeIndex < row.length ? row[incomeIndex] : null,
      expenses: expenseIndex >= 0 && expenseIndex < row.length ? row[expenseIndex] : null,
      currency: file.currency || "USD" // Use file currency or default to USD
    };

    // Skip completely empty rows
    if (!transaction.date && !transaction.description &&
      !transaction.income && !transaction.expenses) {
      return;
    }

    // Apply auto-categorization from file data if present
    if (row.autoCategorized && row.category) {
      transaction.category = row.category;
      transaction.autoGenerated = true;
    }

    transactions.push(transaction);
  });
}

// Add these exposed functions for global access
window.changeTxCategory = function (index, category) {
  const tx = AppState.transactions[index];
  if (!tx) return;

  // Store original if not already stored
  if (!tx.originalData) {
    tx.originalData = {
      date: tx.date,
      description: tx.description,
      income: tx.income,
      expenses: tx.expenses,
      category: tx.category,
      subcategory: tx.subcategory
    };
    tx.edited = true;
  }

  // Update category and clear subcategory when changing categories
  tx.category = category;
  tx.subcategory = null; // Clear subcategory when category changes

  // Save to localStorage
  localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

  // Add to category mapping for future auto-categorization
  if (tx.description && category) {
    addToCategoryMapping(tx.description, category);
  }

  // Update UI
  renderTransactions(AppState.transactions);
};

window.changeTxSubcategory = function (index, subcategory) {
  const tx = AppState.transactions[index];
  if (!tx || !tx.category) return;

  // Store original if not already stored
  if (!tx.originalData) {
    tx.originalData = {
      date: tx.date,
      description: tx.description,
      income: tx.income,
      expenses: tx.expenses,
      category: tx.category,
      subcategory: tx.subcategory
    };
    tx.edited = true;
  }

  // Update subcategory
  tx.subcategory = subcategory;

  // Save to localStorage
  localStorage.setItem("transactions", JSON.stringify(AppState.transactions));

  // Update UI
  renderTransactions(AppState.transactions);
};

window.editTransaction = function (index) {
  // ...existing code for editing transactions...
};

window.revertTransaction = function (index) {
  // ...existing code for reverting transactions...
};

window.deleteTransaction = deleteTransaction;
window.editTransactionCurrency = editTransactionCurrency;

// The createRowHtml function is already defined at line 111

/**
 * Renders category buttons for filtering and adds click handlers
 */
export function renderCategoryButtons() {
  const categoryList = document.getElementById("categoryList");
  if (!categoryList) {
    console.warn("Category list element not found!");
    return;
  }

  // Check if we have categories defined
  if (!AppState.categories || Object.keys(AppState.categories).length === 0) {
    console.warn("No categories found, using default set from constants.js");
    import("../core/constants.js").then(module => {
      AppState.categories = module.DEFAULT_CATEGORIES;
      localStorage.setItem("expenseCategories", JSON.stringify(AppState.categories));
      renderCategoryButtonsInternal(categoryList);
    });
  } else {
    renderCategoryButtonsInternal(categoryList);
  }
}

/**
 * Internal function to render category buttons
 * @param {HTMLElement} categoryList - The container element for category buttons
 */
function renderCategoryButtonsInternal(categoryList) {
  // Initialize currentCategoryFilters if needed
  AppState.currentCategoryFilters = AppState.currentCategoryFilters || [];

  // Get current active categories
  const activeCategories = AppState.currentCategoryFilters || [];

  // Clear existing buttons first
  categoryList.innerHTML = '';

  // Create a button for "All"
  const allButton = document.createElement('button');
  allButton.className = `category-btn ${activeCategories.length === 0 ? 'active' : 'inactive'}`;
  allButton.setAttribute('data-category', 'all');
  allButton.style.cssText = 'background-color: #999; color: white;';
  allButton.textContent = 'All';
  categoryList.appendChild(allButton);

  // Create buttons for each category
  Object.entries(AppState.categories).forEach(([category, value]) => {
    const color = typeof value === 'object' ? value.color : value;
    const textColor = getContrastColor(color);
    const isActive = activeCategories.includes(category);

    const btn = document.createElement('button');
    btn.className = `category-btn ${isActive ? 'active' : 'inactive'}`;
    btn.setAttribute('data-category', category);
    btn.style.cssText = `
      background-color: ${color};
      color: ${textColor};
      ${isActive ? 'box-shadow: 0 0 5px #000; transform: scale(1.05);' : ''}
    `;
    btn.textContent = category;
    categoryList.appendChild(btn);
  });

  // Add click event to each button
  document.querySelectorAll(".category-btn").forEach(btn => {
    btn.addEventListener("click", function () {
      handleCategoryButtonClick(this);
    });
  });

  console.log("Category buttons rendered:", categoryList.childElementCount);
}

/**
 * Handles click events on category filter buttons
 * @param {HTMLElement} button - The clicked button
 */
function handleCategoryButtonClick(button) {
  const category = button.getAttribute("data-category");

  if (category === 'all') {
    // Reset to show all
    AppState.currentCategoryFilters = [];
    document.querySelectorAll(".category-btn").forEach(b => {
      b.classList.toggle('active', b.getAttribute("data-category") === 'all');
      b.classList.toggle('inactive', b.getAttribute("data-category") !== 'all');

      // Add visual cue for active/inactive state
      if (b.getAttribute("data-category") === 'all') {
        b.style.boxShadow = "0 0 5px #000";
        b.style.transform = "scale(1.05)";
      } else {
        b.style.boxShadow = "";
        b.style.transform = "";
      }
    });
  } else {
    // Toggle the clicked category's state
    const allBtn = document.querySelector('.category-btn[data-category="all"]');
    allBtn.classList.remove('active');
    allBtn.classList.add('inactive');
    allBtn.style.boxShadow = "";
    allBtn.style.transform = "";

    button.classList.toggle('active');
    button.classList.toggle('inactive');

    // Add visual feedback
    if (button.classList.contains('active')) {
      button.style.boxShadow = "0 0 5px #000";
      button.style.transform = "scale(1.05)";

      // Add to filter
      if (!AppState.currentCategoryFilters.includes(category)) {
        AppState.currentCategoryFilters.push(category);
      }
    } else {
      button.style.boxShadow = "";
      button.style.transform = "";

      // Remove from filter
      AppState.currentCategoryFilters = AppState.currentCategoryFilters.filter(c => c !== category);
    }
  }

  // Apply the filters to transactions
  const filters = { category: '' };
  applyFilters(filters);
}


// Initialize category buttons when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Wait a moment to ensure the DOM is fully ready
  setTimeout(renderCategoryButtons, 300);
});
